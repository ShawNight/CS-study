# 算法

### 一、栈、队列与堆

栈：**先进后出的线性表**；栈(Stack)是操作系统在建立某个进程时或者线程（在支持多线程的操作系统中是线程）为这个线程建立的存储区域，该区域具有FIFO的特性，在编译的时候可以指定需要的Stack的大小。在编程中，例如C/C++中，所有的局部变量都是从栈中分配内存空间，实际上也不是什么分配，只是从栈顶向上用就行，在退出函数的时候，只是修改栈指针就可以把栈中的内容销毁，所以速度最快

堆：（Heap)是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程，C/C++分别用malloc/New请求分配Heap，用free/delete销毁内存。由于从操作系统管理的内存分配所以在分配和销毁时都要占用时间，所以用堆的效率低的多！但是堆的好处是可以做的很大，C/C++对分配的Heap是不初始化的。

[		`堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。{堆是指程序运行是申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)]()`

队列：**先进后出的线性表**

###### 例1：使用队列实现栈

```C++
class MyStack{
public:
    MyStack(){}
    void push(int x){
        queue<int> temp_data;
        temp_data.push(x);
        while(!_data.empty())
        {
            temp_data.push(_data.front());
            _data.pop();
        }
        while(!temp_data.empty()){
            _data.push(temp_data.front());
            temp_data.pop();
        }
    }
    int pop(){
        int x=_data.front();
        _data.pop();
        return x;
    }
    int top(){
        return _data.front();
    }
    bool empty(){
        return _data.empty();
    }
private:
    queue<int> _data;
};
```

###### 例2：使用栈实现队列

```C++
class MyQueue{
public:
    MyQueue(){}
    void push(int x){
        stack<int> temp_data;
        temp_data.push(x);
        while(!_data.empty()){
            temp_data.push(_data.top());
            _data.pop();
        }
        while(!temp_data.empty()){
            _data.push(temp_data.top());
            temp_data.pop();
        }
    }
    int pop(){
        int x= _data.top();
        _data.pop();
        return x;
    }
    int front(){ return _data.top();}
    bool empty(){ return _data.empty(); }
private:
    stack<int> _data;
};
```

###### 例3：带有min的栈

```C++
class MyStack{
public:
    MyStack(){}
    void push(int x){
        _data.push(x);
        if(_min.empty()||_min.top()>x){
            _min.push(x);
        }else{
            _min.push(_min.top());
        }
    }
    void pop(){
        _min.pop();
        _data.pop();
    }
    int getMin(){ return _min.top();}
    int top(){ return _data.top();}
    bool empty(){return _data.empty();}
private:
    stack<int> _data;
    stack<int> _min;
};
```

###### 例4：合法的出栈序列

```C++
bool check_is_valid_order(queue<int> &order){
    stack<int> S;
    int n=order.size();
    for(int i=1;i<=n;i++){
        S.push(i);
        while(!S.empty()&&order.front()==S.top()){
            order.pop();
            S.pop();
        }
    }
    if(S.empty())
        return true;
    else
        return false;
```

###### 例5：第K大的数

```C++
int findKthLargest(vector<int>& nums,int k){	//最小堆
    priority_queue<int,vector<int>,greater<int>> Q; //优先级队列
    for(int i=0;i<nums.size();i++){
        if(Q.size()<k){
            Q.push(nums[i]);
        }
        else if(Q.top()<nums[i]){
            Q.pop();
            Q.push(nums[i]);
        }
    }
    return Q.top();
}
```

###### 例6：寻找中位数

动态维护一个最大堆与一个最小堆，最大堆存储一半数据，最小堆存储一半数据，维持最大堆的堆顶比最小堆的堆顶小.

情况1：

最大堆与最小堆个数相同，新元素小于最大堆，添加最大堆；新元素大于最大堆，添加最小堆。

情况2：

最大堆比最小堆多一个元素，且新元素小于最大堆：将最大堆的堆顶push进入最小堆；将最大堆的堆顶移除；将新元素添加至最大堆。

最大堆比最小堆多一个元素，且新元素大于最大堆：新元素直接push进入最小堆。

情况3：

最大堆比最小堆少一个元素，且新元素小于最大堆：新元素直接push进入最大堆。

最大堆比最小堆少一个元素，且新元素大于最大堆：将最小堆的堆顶push进入最大堆；将最小堆的堆顶移除；将新元素添加至最小堆。

```C++
class MediaFinder{
public:
    MediaFinder(){
    }
    void addNum(int num){
        if(big_queue.empty()){
            big_queue.push(num);
            return;
        }
        if(big_queue.size()==small_queue.size()){
            if(big_queue.top()>=num){
                big_queue.push(num);
            }else{
                small_queue.push(num);
            }
        }
        else if(big_queue.size()>small_queue.size()){
            if(num>big_queue.top())
                small_queue.push(num);
            else{
                small_queue.push(big_queue.top());
                big_queue.pop();
                big_queue.push(num);
            }
        }else{
            if(num<small_queue.top())
                big_queue.push(num);
            else{
                big_queue.push(small_queue.top());
                small_queue.pop();
                small_queue.push(num);
            }
        }
    }
    int getMid(){
        if(big_queue.size()>=small_queue.size())
            return big_queue.top();
        else{
            return small_queue.top();
        }
    }
private:
    priority_queue<int,vector<int>,greater<int>>  small_queue; //最小堆 //升序队列
    priority_queue<int,vector<int>,less<int>>  big_queue;	//最大堆 //降序队列
};

```

### 二、链表







### 三、贪心算法

$\textcolor{red}{基本概念}$：所谓贪心算法是指，在对问题求解时，总是**做出在当前看来是最好的选择**。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的**局部最优解**。
 贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）
 **所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。**

$\textcolor{red}{基本思路}$：

- 建立数学模型来描述问题
- 把求解的问题分成若干个子问题
- 对每个子问题求解，得到子问题的局部最优解
- 把子问题的解局部最优解合成原来问题的一个解

$\textcolor{red}{存在的问题}$：

- 不能保证求得的最后解是最佳的
- 不能用来求最大值或最小值的问题
- 只能求满足某些约束条件的可行解的范围

###### 例1：分糖果

> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>

假设g=[5,10,2,9,15,9] ; s=[6,1,20,3,8];

先进行排序g=[ 2,5,9,9,10,15];  s=[1,3,6,8,20]

1、如果饼干不能满足某个孩子，那么肯定不能满足需求因子更大的孩子；

2、如果某个饼干可以满足某个孩子，那么不需要用更大的糖果满足他；

综上可知，尽量让更大的饼干满足需求因子更大的孩子；那么从小到大遍历饼干，并且从小到大尝试是否可以满足某个孩子，满足的话，继续从下一个饼干尝试是否能满足下一个孩子。

```C++
int FindContentChildren(vector<int>& g,vector<int>& s){
    sort(g.begin(),g.end());
    sort(s.begin(),s.end());
    int child=0;
    int cookie=0;
    while(cookie<s.size()&&child<g.size()){
        if(s[cookie]>=g[child])
            child++;
        cookie++;
    }
    return child;
}
```

###### 例2：摇摆序列

> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
> 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。
>
> 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
> 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
> 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。
>
> 示例 1：输入：nums = [1,7,4,9,2,5]  输出：6
>
> 输入：nums = [1,17,5,10,13,15,10,5,16,8]  输出：7      解释：这个序列包含几个长度为 7 摆动序列。
> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。

分析：

状态转换机：

![image-20210701233908002](E:\文件资料\C++\image-20210701233908002.png)

```C++
int wiggleMaxLength(vector<int>& nums) {
    int len=nums.size();
    if(len<2) return len;
    int count=1;
    for(int i=1;i<len;i++){
        if(nums[i-1]<nums[i]){
            while(i<len&&nums[i-1]<=nums[i]){
                i++;
            }
            count++;
            i--;
        }else if(nums[i-1]>nums[i]){
            while(i<len&&nums[i-1]>=nums[i]){
                i++;
            }
            count++;
            i--;
        }
    }
    return count;
}
状态机：
int wiggleMaxLength(vector<int>& nums) {
        int len=nums.size();
        if(len<2)
            return len;
        static const int BEGIN=0;
        static const int UP=1;
        static const int DOWN=2;
        int START=BEGIN;
        int max_length=1;
        for(int i=1;i<len;i++){
            switch(START)
            {
                case BEGIN:
                    if(nums[i-1]<nums[i]){
                        START=UP;
                        max_length++;
                    }else if(nums[i-1]>nums[i])
                    {
                        START=DOWN;
                        max_length++;
                    }
                    break;
                case UP:
                    if(nums[i-1]>nums[i]){
                        START=DOWN;
                        max_length++;
                    }
                    break;
                case DOWN:
                    if(nums[i-1]<nums[i])
                    {
                        START=UP;
                        max_length++;
                    }
                    break;
            }
        }
        return max_length;   
    }
```

###### 例3：移除K个数字（402）

给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

**示例 1 ：**

```
输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
```

**示例 2 ：**

```
输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```

**示例 3 ：**

```
输入：num = "10", k = 2
输出："0"
解释：从原数字移除所有的数字，剩余为空就是 0 。
```

**提示：**

- `1 <= k <= num.length <= 105`
- `num` 仅由若干位数字（0 - 9）组成
- 除了 **0** 本身之外，`num` 不含任何前导零



分析：要想数最小则，越高位的数字越小，数字越小，创建一个栈，每次往里添加数据，如果要添加的数比栈顶小，则移除栈顶，相应k--；直到栈为空或者栈顶元素大于当前数或者没有可以移除的次数k，则把当前数添加入栈顶。

```C++
string removeKdigits(string num, int k) {
        vector<char> stk;
        for (auto& digit: num) {
            while (stk.size() > 0 && stk.back() > digit && k) {
                stk.pop_back();
                k -= 1;
            }
            stk.push_back(digit);
        }

        for (; k > 0; --k) {
            stk.pop_back();
        }

        string ans = "";
        bool isLeadingZero = true;
        for (auto& digit: stk) {
            if (isLeadingZero && digit == '0') {
                continue;
            }
            isLeadingZero = false;
            ans += digit;
        }
        return ans == "" ? "0" : ans;
 }
```

###### 例4：跳跃游戏(55)

给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

**示例 1：**

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

**示例 2：**

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```

```C++
bool canJump(vector<int>& nums) {
    int len=nums.size()-1;
    if(len==0) return true;
    int i=0;
    int max=nums[0];
    while(max<len&&i<max){
        i++;
        int now=i+nums[i];
        max=max<now?now:max;
    }
    if(max<len)
        return false;
    else
        return true;
}
```

