# 十大排序算法

**一、算法概述**

0.1 算法分类

十种常见排序算法可以分为两大类：

> **非线性时间比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此称为非线性时间比较类排序。
>
> **线性时间非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 

> 为线性时间非比较类排序。 

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402132530342-980121409.png)

#### 0.2 算法复杂度

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

**0.3 相关概念**

> **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
>
> **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
>
> **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
>
> **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。

#### 1、冒泡排序

冒泡排序在扫描过程中两两比较相邻记录，如果反序则交换，最终，最大记录就被“沉到”了序列的最后一个位置，第二遍扫描将第二大记录“沉到”了倒数第二个位置，重复上述操作，直到n-1 遍扫描后，整个序列就排好序了。

![img](https://img-blog.csdn.net/20180327153510444?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWUUxMjE1MTcyMzg1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

```C++
//冒泡排序
void BubbleSort(vector<int> &arr){
    int len = arr.size();
    int i,j;
    for(i=0; i<len-1; i++){
        for(j=0; j<len-1;j++){
            if(arr[j]>arr[j+1])
                swap(arr[j],arr[j+1]);
        }
    }
}
```

#### 2、选择排序

选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：**初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。**

注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。

```C++
//选择排序
void SelectionSort(vector<int> &arr){
    int len = arr.size();
    int i,j;
    for(i=0;i<len;i++){
        int minIndex=i;
        for(j=len-1;j>i;j--){
            if(arr[j]<arr[minIndex]) minIndex=j;
        }
        swap(arr[minIndex],arr[i]);
    }
}
```

#### 3、插入排序

直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下：

- 对于一个数组A[0,n]的排序问题，假设认为数组在A[0,n-1]排序的问题已经解决了。
- 考虑A[n]的值，从右向左扫描有序数组A[0,n-1]，直到第一个小于等于A[n]的元素，将A[n]插在这个元素的后面。

　　很显然，基于增量法的思想在解决这个问题上拥有更高的效率。

直接插入排序对于最坏情况（严格递减的数组），需要比较和移位的次数为n(n-1)/2；对于最好的情况（严格递增的数组），需要比较的次数是n-1，需要移位的次数是0。当然，对于最好和最坏的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序）。直接插入排序的时间复杂度是O(n^2)，空间复杂度是O(1)，同时也是稳定排序。直接插入排序（straight insertion sort），有时也简称为插入排序（insertion sort），是减治法的一种典型应用。其基本思想如下：

- 对于一个数组A[0,n]的排序问题，假设认为数组在A[0,n-1]排序的问题已经解决了。
- 考虑A[n]的值，从右向左扫描有序数组A[0,n-1]，直到第一个小于等于A[n]的元素，将A[n]插在这个元素的后面。

　　很显然，基于增量法的思想在解决这个问题上拥有更高的效率。

直接插入排序对于最坏情况（严格递减的数组），需要比较和移位的次数为n(n-1)/2；对于最好的情况（严格递增的数组），需要比较的次数是n-1，需要移位的次数是0。当然，对于最好和最坏的研究其实没有太大的意义，因为实际情况下，一般不会出现如此极端的情况。然而，直接插入排序对于基本有序的数组，会体现出良好的性能，这一特性，也给了它进一步优化的可能性。（希尔排序）。直接插入排序的时间复杂度是O(n^2)，空间复杂度是O(1)，同时也是稳定排序。

```C++
void InsertSort(vector<int> &arr){
    int len = arr.size();
    int i,j;
    for(i=1;i<len;i++){
        for(j=i;j>0;j--){
            if(arr[j]<arr[j-1])
                swap(arr[j],arr[j-1]);
            else
                break;
        }
    }
}
```

#### 4、快速排序

假设我们现在对“6  1  2 7  9  3  4  5 10  8”这个10个数进行排序。首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，就是一个用来参照的数，待会你就知道它用来做啥的了）。为了方便，就让第一个数6作为基准数吧。接下来，需要将这个序列中所有比基准数大的数放在6的右边，比基准数小的数放在6的左边，类似下面这种排列：

```
3  1  2 5  4  6  9 7  10  8
```

在初始状态下，数字6在序列的第1位。我们的目标是将6挪到序列中间的某个位置，假设这个位置是k。现在就需要寻找这个k，并且以第k位为分界点，左边的数都小于等于6，右边的数都大于等于6，递归对左右两个区间进行同样排序即可。想一想，你有办法可以做到这点吗？这就是快速排序所解决的问题。

快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。它的平均时间复杂度为O(nlogn)，最坏时间复杂度为O(n^2).

首先上图：

![img](https://images2018.cnblogs.com/blog/1000464/201807/1000464-20180726204437671-1976983281.png)

 

 从图中我们可以看到：

left指针，right指针，base参照数。

其实思想是蛮简单的，就是通过第一遍的遍历（让left和right指针重合）来找到数组的切割点。

第一步：首先我们从数组的left位置取出该数（20）作为基准（base）参照物。(如果是选取随机的，则找到随机的哨兵之后，将它与第一个元素交换，开始普通的快排)

第二步：从数组的right位置向前找，一直找到比（base）小的数，如果找到，将此数赋给left位置（也就是将10赋给20），此时数组为：10，40，50，10，60， left和right指针分别为前后的10。

第三步：从数组的left位置向后找，一直找到比（base）大的数，如果找到，将此数赋给right的位置（也就是40赋给10），此时数组为：10，40，50，40，60， left和right指针分别为前后的40。

第四步：重复“第二,第三“步骤，直到left和right指针重合，最后将（base）放到40的位置， 此时数组值为： 10，20，50，40，60，至此完成一次排序。

第五步：此时20已经潜入到数组的内部，20的左侧一组数都比20小，20的右侧作为一组数都比20大， 以20为切入点对左右两边数按照"第一，第二，第三，第四"步骤进行，最终快排大功告成。

```C++
//快速排序
void QuickSort(vector<int> &arr,int left,int right){
    if(arr.size()==0) return;
    if(left>=right) return;
    //防止有序队列导致快速排序效率降低
    srand((int)time(0));
    int len=right-left;
    int index=rand()%(len+1)+left;
    swap(arr[left],arr[index]);

    int key=arr[left],i=left,j=right;
    while(i<j)
    {
        while(arr[j]>=key && i<j) --j;
        if(i<j) arr[i]=arr[j];
        while(arr[i]<key && i<j) ++i;
        if(i<j) arr[j]=arr[i];
    }
    arr[i]=key;
    QuickSort(arr,left,i-1);
    QuickSort(arr,j+1,right);
}
```

#### 5、归并排序

归并排序（MERGE-SORT）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（divide-and-conquer）策略（分治法将问题**分**(divide)成一些小的问题然后递归求解，而**治(conquer)**的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。**
**

**分而治之**

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218163120151-452283750.png)

 　可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。

# 合并相邻有序子序列

　　再来看看**治**阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194508761-468169540.png)

![img](https://images2015.cnblogs.com/blog/1024555/201612/1024555-20161218194621308-588010220.png)

 